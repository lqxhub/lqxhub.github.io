<!doctype html><html lang=zh-cn dir=ltr><head><meta charset=utf-8><meta name=viewport content='width=device-width,initial-scale=1'><meta name=description content="C++中变量的生命周期与作用域是有差别的，再结左值引用和右值引用，引用折叠，这次就来浅谈一下C++中变量的生命周期。"><meta name=keywords content="C++,,变量,,生命周期,,作用域"><title>C++变量生命周期，结左值引用和右值引用，引用折叠，这次就来浅谈一下C++中变量的生命周期 - QX's blog</title>
<link rel=canonical href=https://lqxhub.github.io/posts/567e834f/><link rel=stylesheet href=/scss/style.min.cf20c5703e90831fa8051409d1786e3338f2624d07c5fe5f37ce747dbe09923c.css><meta property='og:title' content="C++变量生命周期，结左值引用和右值引用，引用折叠，这次就来浅谈一下C++中变量的生命周期 - QX's blog"><meta property='og:description' content="C++中变量的生命周期与作用域是有差别的，再结左值引用和右值引用，引用折叠，这次就来浅谈一下C++中变量的生命周期。"><meta property='og:url' content='https://lqxhub.github.io/posts/567e834f/'><meta property='og:site_name' content='QX 的笔记'><meta property='og:type' content='article'><meta property='article:section' content='Post'><meta property='article:tag' content='C++'><meta property='article:published_time' content='2025-03-09T18:01:29+08:00'><meta property='article:modified_time' content='2025-03-09T18:01:29+08:00'><meta property='og:image' content='https://cdn.jsdelivr.net/gh/lqxhub/images@master/blog/0677f36b25f64ef20bd9b0ff4317dee12d1c8c4e.jpg'><meta name=twitter:title content="C++变量生命周期，结左值引用和右值引用，引用折叠，这次就来浅谈一下C++中变量的生命周期 - QX's blog"><meta name=twitter:description content="C++中变量的生命周期与作用域是有差别的，再结左值引用和右值引用，引用折叠，这次就来浅谈一下C++中变量的生命周期。"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content='https://cdn.jsdelivr.net/gh/lqxhub/images@master/blog/0677f36b25f64ef20bd9b0ff4317dee12d1c8c4e.jpg'><link rel="shortcut icon" href=/favicon.ico><meta name=google-site-verification content="Ts78qICcAFtPJZg7DfwjJYFH2BsbYh7ICe1k6xMb-C8"><meta name=msvalidate.01 content="C538647907B2EAEBE650AAC7463E551F"><script async src="https://www.googletagmanager.com/gtag/js?id=G-BM48R77LCS"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-BM48R77LCS")</script><script src=https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js></script><link rel=stylesheet href=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css><script src=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js></script><script src=https://fastly.jsdelivr.net/gh/stevenjoezhang/live2d-widget@latest/autoload.js></script><style>#waifu #live2d{cursor:grab;height:260px;position:relative;width:260px}#waifu-tips{width:230px}</style><div class=top-scroll-bar></div><style>.top-scroll-bar{position:fixed;top:0;left:0;z-index:9999;display:none;width:0;height:3px;background:#ef3982}</style><script>$(document).ready(function(){$(window).scroll(function(){$(".top-scroll-bar").attr("style","width: "+$(this).scrollTop()/($(document).height()-$(this).height())*100+"%; display: block;")})})</script><div id=back-top><a href=#top title=回到顶部></a></div><style>#back-top{position:fixed;bottom:30px;right:80px}#back-top a{width:54px;height:54px;display:block;background:#ddd url(/images/back_top.svg)no-repeat 50%;background-color:rgba(218,214,214,.87);-webkit-border-radius:7px;-moz-border-radius:7px;border-radius:7px;-webkit-transition:1s;-moz-transition:1s;transition:1s}#back-top a:hover{background-color:#e88282}</style><script type=text/javascript>$("#back-top").hide(),$(document).ready(function(){$(window).scroll(function(){$(this).scrollTop()>100?$("#back-top").fadeIn():$("#back-top").fadeOut()}),$("#back-top a").click(function(){return $("body,html").animate({scrollTop:0},800),!1})})</script></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label=切换菜单>
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/><img src=/img/avatar_hu14972274666183315035.gif width=300 height=300 class=site-logo loading=lazy alt=Avatar>
</a><span class=emoji>😉</span></figure><div class=site-meta><h1 class=site-name><a href=/>QX 的笔记</a></h1><h2 class=site-description>雄关漫道真如铁，而今迈步从头越</h2></div></header><ol class=menu-social><li><a href=mailto:lqxlucky@qq.com target=_blank title=Email rel=me><svg fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" class="icon icon-tabler icon-tabler-mail-flat"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M4 4h16a2 2 0 012 2v12a2 2 0 01-2 2H4a2 2 0 01-2-2V6a2 2 0 012-2z"/><path d="M4 6l8 5 8-5"/></svg></a></li><li><a href=https://github.com/lqxhub target=_blank title=GitHub rel=me><svg class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></a></li><li><a href=/index.xml target=_blank title="RSS Feed" rel=me><svg class="icon icon-tabler icon-tabler-rss" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="5" cy="19" r="1"/><path d="M4 4a16 16 0 0116 16"/><path d="M4 11a9 9 0 019 9"/></svg></a></li></ol><ol class=menu id=main-menu><li><a href=/><svg class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg>
<span>首页</span></a></li><li><a href=/categories><svg class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg>
<span>分类</span></a></li><li><a href=/archives><svg class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg>
<span>归档</span></a></li><li><a href=/tags><svg class="icon icon-tabler icon-tabler-tag" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11 3l9 9a1.5 1.5.0 010 2l-6 6a1.5 1.5.0 01-2 0L3 11V7a4 4 0 014-4h4"/><circle cx="9" cy="9" r="2"/></svg>
<span>标签</span></a></li><li><a href=/collect><svg fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" class="icon icon-tabler icon-tabler-bookmark"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M5 4h14a1 1 0 011 1v16l-8-4-8 4V5a1 1 0 011-1z"/></svg>
<span>收藏</span></a></li><li><a href=/tool><svg fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" class="icon icon-tabler icon-tabler-tools"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 15l-4 4m0-4 4 4"/><path d="M15 9l4-4m0 4-4-4"/><path d="M9 9l6 6"/><path d="M12 12l2-2"/><path d="M15 15l-2 2"/></svg>
<span>工具</span></a></li><li><a href=/friend><svg class="icon icon-tabler icon-tabler-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M10 14a3.5 3.5.0 005 0l4-4a3.5 3.5.0 00-5-5l-.5.5"/><path d="M14 10a3.5 3.5.0 00-5 0l-4 4a3.5 3.5.0 005 5l.5-.5"/></svg>
<span>友链</span></a></li><li><a href=/search><svg class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg>
<span>搜索</span></a></li><li><a href=/about><svg class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="7" r="4"/><path d="M6 21v-2a4 4 0 014-4h4a4 4 0 014 4v2"/></svg>
<span>关于</span></a></li><li class=menu-bottom-section><ol class=menu><li id=dark-mode-toggle><svg class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<svg class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<span>暗色模式</span></li></ol></li></ol></aside><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">目录</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#bug分析>bug分析</a></li><li><a href=#左值右值>左值、右值</a><ol><li><a href=#左值>左值</a></li><li><a href=#右值>右值</a><ol><li><a href=#纯右值>纯右值</a></li><li><a href=#将亡值>将亡值</a></li></ol></li></ol></li><li><a href=#变量的生命周期>变量的生命周期</a><ol><li><a href=#左值-1>左值</a></li><li><a href=#右值-1>右值</a></li><li><a href=#声明周期的延长>声明周期的延长</a></li></ol></li><li><a href=#左值引用右值引用>左值引用、右值引用</a><ol><li><a href=#左值引用>左值引用</a></li><li><a href=#右值引用>右值引用</a></li><li><a href=#引用折叠>引用折叠</a></li></ol></li><li><a href=#总结>总结</a></li></ol></nav></div></section></aside><main class="main full-width"><article class="has-image main-article"><header class=article-header><div class=article-image><a href=/posts/567e834f/><img src=https://cdn.jsdelivr.net/gh/lqxhub/images@master/blog/0677f36b25f64ef20bd9b0ff4317dee12d1c8c4e.jpg loading=lazy alt="Featured image of post C++变量生命周期，结左值引用和右值引用，引用折叠，这次就来浅谈一下C++中变量的生命周期 - QX's blog"></a></div><div class=article-details><header class=article-category><a href=/categories/c++/>C++</a></header><div class=article-title-wrapper><h2 class=article-title><a href=/posts/567e834f/>C++变量生命周期</a></h2><h3 class=article-subtitle>C++中变量的生命周期与作用域是有差别的，再结左值引用和右值引用，引用折叠，这次就来浅谈一下C++中变量的生命周期。</h3></div><footer class=article-time><div><svg class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published>Mar 09, 2025</time></div><div><svg class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<time class=article-time--reading>阅读时长: 8 分钟</time></div></footer></div></header><section class=article-content><p>在C++11及以后的版本中，可以将变量简单的分为左值，右值。其中右值又可以分为纯右值和将亡值。
不同类型的变量的生命周期与作用域也是有差别的，这次就来浅谈一下C++中变量的生命周期。</p><p>事情的起因是最近在修一个C++的bug时，发现是因为变量的生命周期问题导致的，所以就来总结一下。</p><p><a class=link href=https://github.com/arana-db/kiwi-cpp/pull/204 target=_blank rel=noopener>提交的PR</a></p><p><a class=link href=https://github.com/arana-db/kiwi-cpp/pull/204/files#diff-e56b7c4d89acbd94e631feed9aaf7a2621967b3cb920a96e1c87e2a57779cc3bL65 target=_blank rel=noopener>代码位置</a></p><h2 id=bug分析><a href=#bug%e5%88%86%e6%9e%90 class=header-anchor></a>bug分析</h2><p>有bug的代码如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span>HashesMetaValue <span style=color:#50fa7b>tmf_meta_value2</span>(DataType<span style=color:#ff79c6>::</span>kHashes, std<span style=color:#ff79c6>::</span>string(str, <span style=color:#ff79c6>sizeof</span>(<span style=color:#8be9fd>int32_t</span>)));
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span><span style=color:#ff79c6>using</span> HashesMetaValue <span style=color:#ff79c6>=</span> BaseMetaValue;
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2</span><span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3</span><span><span style=color:#ff79c6>class</span> <span style=color:#50fa7b>BaseMetaValue</span> <span style=color:#ff79c6>:</span> <span style=color:#ff79c6>public</span> InternalValue {
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4</span><span> <span style=color:#ff79c6>public</span><span style=color:#ff79c6>:</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5</span><span>  <span style=color:#ff79c6>explicit</span> BaseMetaValue(DataType type, <span style=color:#ff79c6>const</span> Slice<span style=color:#ff79c6>&amp;</span> user_value) <span style=color:#ff79c6>:</span> InternalValue(type, user_value) {}
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6</span><span>  ...................
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">7</span><span>};
</span></span></code></pre></div><p>可以看到，<code>BaseMetaValue</code>的构造函数接受的是<code>const Slice&</code>类型的参数，
而<code>std::string(str, sizeof(int32_t))</code>是一个临时变量，是一个右值(将亡值)，
所以这个临时变量的生命周期只在这一行代码中，当这一行代码执行完后，这个临时变量就会被销毁，
所以<code>tmf_meta_value2</code>的<code>user_value</code>就是一个悬空指针，所以在后面的代码中就会出现问题。</p><p><code>Slice</code> 是一个类似于<code>std::string_view</code>的类，<code>Slice</code>不拥有数据，只是一个指向数据的指针。所以必须由调用者保证数据的生命周期。</p><p>解决方法也很简单，将<code>BaseMetaValue</code>的构造函数改为接受<code>std::string</code>类型的参数即可。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span><span style=color:#ff79c6>auto</span> key <span style=color:#ff79c6>=</span> std<span style=color:#ff79c6>::</span>string(str, <span style=color:#ff79c6>sizeof</span>(<span style=color:#8be9fd>int32_t</span>));
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2</span><span>HashesMetaValue <span style=color:#50fa7b>tmf_meta_value1</span>(DataType<span style=color:#ff79c6>::</span>kHashes, key);
</span></span></code></pre></div><p>这样<code>key</code>就是一个左值，生命周期会持续到<code>tmf_meta_value1</code>的生命周期结束。所以就不会出现悬空指针的问题了。</p><p>C++中没有严格限制变量的生命周期，我没有系统的学习过rust，但是了解过rust的一些概念，rust中有严格的生命周期检查，这样就可以避免很多悬空指针的问题，
上述的bug在rust中是不会出现的。因为rust中有严格的变量所有权的，生命周期检查。 <strong>所有权</strong> 这个概念在rust中是非常重要，我觉得这个概念在C++中也是很重要的，
想要写出高质量的代码，就需要了解这所有权这个概念。</p><h2 id=左值右值><a href=#%e5%b7%a6%e5%80%bc%e5%8f%b3%e5%80%bc class=header-anchor></a>左值、右值</h2><h3 id=左值><a href=#%e5%b7%a6%e5%80%bc class=header-anchor></a>左值</h3><p>最简单的一个例子就是变量，变量是一个左值，它有一个内存地址，可以取地址，可以修改。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span><span style=color:#8be9fd>int</span> a <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>10</span>;  <span style=color:#6272a4>// a 是左值
</span></span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2</span><span><span style=color:#6272a4></span><span style=color:#8be9fd>int</span><span style=color:#ff79c6>*</span> p <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>&amp;</span>a; <span style=color:#6272a4>// 可以取 a 的地址
</span></span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3</span><span><span style=color:#6272a4></span>a <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>20</span>;      <span style=color:#6272a4>// a 可以被赋值
</span></span></span></code></pre></div><h3 id=右值><a href=#%e5%8f%b3%e5%80%bc class=header-anchor></a>右值</h3><p>右值是指不能取地址的临时对象或值，通常是短暂存在的（ephemeral），无法出现在赋值语句的左侧。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span><span style=color:#8be9fd>int</span> b <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>5</span> <span style=color:#ff79c6>+</span> <span style=color:#bd93f9>3</span>; <span style=color:#6272a4>// 5 + 3 是右值（纯右值）
</span></span></span></code></pre></div><p>其中右值又可以分为纯右值和将亡值。</p><h4 id=纯右值><a href=#%e7%ba%af%e5%8f%b3%e5%80%bc class=header-anchor></a>纯右值</h4><p>特性：没有身份，无法取地址，无法被赋值</p><p>常见的 <strong>字面量</strong>、<strong>临时对象</strong>、<strong>函数返回值</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span><span style=color:#bd93f9>42</span>;          <span style=color:#6272a4>// 字面量是纯右值
</span></span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2</span><span><span style=color:#6272a4></span><span style=color:#bd93f9>5</span> <span style=color:#ff79c6>+</span> <span style=color:#bd93f9>3</span>;       <span style=color:#6272a4>// 计算结果是纯右值
</span></span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3</span><span><span style=color:#6272a4></span>std<span style=color:#ff79c6>::</span>string(<span style=color:#f1fa8c>&#34;hello&#34;</span>); <span style=color:#6272a4>// 构造函数返回的临时对象是纯右值
</span></span></span></code></pre></div><h4 id=将亡值><a href=#%e5%b0%86%e4%ba%a1%e5%80%bc class=header-anchor></a>将亡值</h4><p>将亡值是“即将消亡的值”，通常是通过右值引用绑定到的临时对象，或者被显式移动（move）的对象。</p><p>特性：有身份（可以取地址），但生命周期即将结束</p><p>通常出现在使用 <code>std::move</code> 或函数返回右值引用的场景</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span><span style=color:#ff79c6>#include</span> <span style=color:#ff79c6>&lt;utility&gt;</span><span style=color:#ff79c6>
</span></span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2</span><span><span style=color:#ff79c6></span><span style=color:#8be9fd>int</span><span style=color:#ff79c6>&amp;&amp;</span> getRvalue() { <span style=color:#ff79c6>return</span> <span style=color:#bd93f9>42</span>; }
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3</span><span><span style=color:#8be9fd>int</span> <span style=color:#50fa7b>main</span>() {
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4</span><span>    <span style=color:#8be9fd>int</span> a <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>10</span>;
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5</span><span>    <span style=color:#8be9fd>int</span><span style=color:#ff79c6>&amp;&amp;</span> r1 <span style=color:#ff79c6>=</span> std<span style=color:#ff79c6>::</span>move(a); <span style=color:#6272a4>// std::move(a) 是将亡值
</span></span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6</span><span><span style=color:#6272a4></span>    <span style=color:#8be9fd>int</span><span style=color:#ff79c6>&amp;&amp;</span> r2 <span style=color:#ff79c6>=</span> getRvalue();  <span style=color:#6272a4>// getRvalue() 返回的临时对象是将亡值
</span></span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">7</span><span><span style=color:#6272a4></span>}
</span></span></code></pre></div><h2 id=变量的生命周期><a href=#%e5%8f%98%e9%87%8f%e7%9a%84%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f class=header-anchor></a>变量的生命周期</h2><h3 id=左值-1><a href=#%e5%b7%a6%e5%80%bc-1 class=header-anchor></a>左值</h3><p>左值的生命周期由存储期决定，通常是持久的，可以控制。比如局部变量，离开作用域后会被销毁。
动态分配的内存也是左值，需要手动释放。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span><span style=color:#8be9fd>void</span> <span style=color:#50fa7b>example</span>() {
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2</span><span>    <span style=color:#8be9fd>int</span> a <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>10</span>;         <span style=color:#6272a4>// 左值 a，自动存储期，离开作用域销毁
</span></span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3</span><span><span style=color:#6272a4></span>    <span style=color:#ff79c6>static</span> <span style=color:#8be9fd>int</span> b <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>20</span>;  <span style=color:#6272a4>// 左值 b，静态存储期，程序结束销毁
</span></span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4</span><span><span style=color:#6272a4></span>    <span style=color:#8be9fd>int</span><span style=color:#ff79c6>*</span> p <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> <span style=color:#8be9fd>int</span>(<span style=color:#bd93f9>30</span>); <span style=color:#6272a4>// 左值 *p，动态存储期，直到 delete
</span></span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5</span><span><span style=color:#6272a4></span>    <span style=color:#ff79c6>delete</span> p;
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6</span><span>}
</span></span></code></pre></div><ul><li><code>a</code> 的生命周期从定义到函数结束。</li><li><code>b</code> 的生命周期贯穿整个程序。</li><li><code>p</code> 的生命周期从 <code>new</code> 到 <code>delete</code>。</li></ul><h3 id=右值-1><a href=#%e5%8f%b3%e5%80%bc-1 class=header-anchor></a>右值</h3><ul><li>纯右值：生命周期短暂，表达式结束后销毁，一旦表达式求值完成，纯右值要么被销毁，要么被用于初始化其他对象</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span><span style=color:#8be9fd>int</span> <span style=color:#50fa7b>main</span>() {
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2</span><span>    <span style=color:#bd93f9>5</span> <span style=color:#ff79c6>+</span> <span style=color:#bd93f9>3</span>; <span style=color:#6272a4>// 纯右值，表达式结束后销毁
</span></span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3</span><span><span style=color:#6272a4></span>    std<span style=color:#ff79c6>::</span>string s <span style=color:#ff79c6>=</span> std<span style=color:#ff79c6>::</span>string(<span style=color:#f1fa8c>&#34;hello&#34;</span>); <span style=color:#6272a4>// 临时对象是纯右值，构造 s 后销毁
</span></span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4</span><span><span style=color:#6272a4></span>    <span style=color:#ff79c6>const</span> <span style=color:#8be9fd>int</span><span style=color:#ff79c6>&amp;</span> ref <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>42</span>; <span style=color:#6272a4>// 纯右值 42 的生命周期延长到 ref 的作用域结束
</span></span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5</span><span><span style=color:#6272a4></span>}
</span></span></code></pre></div><ul><li>将亡值：生命周期取决于底层对象，通常是短暂的，或者可以被转移，可以通过右值引用绑定延长生命周期</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span>std<span style=color:#ff79c6>::</span>string<span style=color:#ff79c6>&amp;&amp;</span> rvalue <span style=color:#ff79c6>=</span> std<span style=color:#ff79c6>::</span>move(str); <span style=color:#6272a4>// str 是将亡值，通过 std::move 转为右值引用，延长生命周期
</span></span></span></code></pre></div><h3 id=声明周期的延长><a href=#%e5%a3%b0%e6%98%8e%e5%91%a8%e6%9c%9f%e7%9a%84%e5%bb%b6%e9%95%bf class=header-anchor></a>声明周期的延长</h3><ul><li>绑定到常量左值引用 <code>const &</code>
当纯右值绑定到 <code>const T&</code> 时，临时对象的生命周期延长到引用的作用域结束。<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span><span style=color:#ff79c6>const</span> std<span style=color:#ff79c6>::</span>string<span style=color:#ff79c6>&amp;</span> str <span style=color:#ff79c6>=</span> std<span style=color:#ff79c6>::</span>string(<span style=color:#f1fa8c>&#34;temp&#34;</span>); <span style=color:#6272a4>// str 有效直到作用域结束
</span></span></span></code></pre></div></li><li>绑定到右值引用<code>&&</code>
当右值（纯右值或将亡值）绑定到 <code>T&&</code> 时，临时对象的生命周期延长到右值引用的作用域结束。<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span>std<span style=color:#ff79c6>::</span>string<span style=color:#ff79c6>&amp;&amp;</span> str <span style=color:#ff79c6>=</span> std<span style=color:#ff79c6>::</span>string(<span style=color:#f1fa8c>&#34;temp&#34;</span>); <span style=color:#6272a4>// str 有效直到作用域结束
</span></span></span></code></pre></div></li></ul><div class=table-wrapper><table><thead><tr><th>值类别</th><th>生命周期特点</th><th>是否可延长生命周期</th><th>示例场景</th></tr></thead><tbody><tr><td>左值 (lvalue)</td><td>由存储期决定，持久且可控</td><td>不需要延长，本身持久</td><td>局部变量、全局变量</td></tr><tr><td>纯右值 (prvalue)</td><td>临时，表达式结束后销毁</td><td>可通过 const & 延长</td><td>字面量、临时对象</td></tr><tr><td>将亡值 (xvalue)</td><td>取决于底层对象，通常短暂或可转移</td><td>可通过 && 绑定延长</td><td>std::move、函数返回右值引用</td></tr></tbody></table></div><h2 id=左值引用右值引用><a href=#%e5%b7%a6%e5%80%bc%e5%bc%95%e7%94%a8%e5%8f%b3%e5%80%bc%e5%bc%95%e7%94%a8 class=header-anchor></a>左值引用、右值引用</h2><p>单纯的左值和右值其实还是好理解的，但是结合C++中的引用，就会有一些特殊的情况，比如右值引用绑定到左值，
右值引用绑定到右值等等，这些情况就需要我们去了解C++中的引用的特性。</p><h3 id=左值引用><a href=#%e5%b7%a6%e5%80%bc%e5%bc%95%e7%94%a8 class=header-anchor></a>左值引用</h3><p>先来看一下最简单的左值引用，我的理解，左值引用可以理解为一个别名，它是一个左值，可以取地址，可以修改，可以看做是一种简化的指针。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span><span style=color:#8be9fd>int</span> a <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>42</span>;
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2</span><span><span style=color:#8be9fd>int</span><span style=color:#ff79c6>&amp;</span> ref <span style=color:#ff79c6>=</span> a;  <span style=color:#6272a4>// 左值引用，绑定到左值
</span></span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3</span><span><span style=color:#6272a4></span>ref <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>100</span>;     <span style=color:#6272a4>// 修改ref实际上就是修改a
</span></span></span></code></pre></div><p>左值引用中，还有一个特殊的情况，就是 const 左值引用，它可以绑定到右值，但是不能修改。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span><span style=color:#ff79c6>const</span> <span style=color:#8be9fd>int</span><span style=color:#ff79c6>&amp;</span> ref <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>42</span>; <span style=color:#6272a4>// const 左值引用，绑定到右值
</span></span></span></code></pre></div><p><strong>const</strong> 类型的左值引用，常用在函数的参数中，可以接受左值和右值。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span><span style=color:#8be9fd>void</span> <span style=color:#50fa7b>func</span>(<span style=color:#ff79c6>const</span> <span style=color:#8be9fd>int</span><span style=color:#ff79c6>&amp;</span> ref) {
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2</span><span>    <span style=color:#6272a4>// ref 可以绑定到左值或右值
</span></span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3</span><span><span style=color:#6272a4></span>}
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4</span><span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5</span><span><span style=color:#8be9fd>int</span> <span style=color:#50fa7b>main</span>() {
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6</span><span>    <span style=color:#8be9fd>int</span> a <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>42</span>;
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">7</span><span>    func(a); <span style=color:#6272a4>// a 是左值
</span></span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">8</span><span><span style=color:#6272a4></span>    func(<span style=color:#bd93f9>42</span>); <span style=color:#6272a4>// 42 是右值
</span></span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">9</span><span><span style=color:#6272a4></span>}
</span></span></code></pre></div><p>为什么 <strong>const</strong> 左值引用可以绑定到右值呢？因为右值是临时的，不会被修改，const修饰的变量是不可以修改的，
所以可以绑定到const左值引用。</p><h3 id=右值引用><a href=#%e5%8f%b3%e5%80%bc%e5%bc%95%e7%94%a8 class=header-anchor></a>右值引用</h3><p>右值引用是C++11引入的新特性，它是一个新的引用类型，用于绑定到右值。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span><span style=color:#8be9fd>int</span><span style=color:#ff79c6>&amp;&amp;</span> rref <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>100</span>; <span style=color:#6272a4>// 右值引用，绑定到右值
</span></span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2</span><span><span style=color:#6272a4></span><span style=color:#8be9fd>int</span> x <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>101</span>；
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3</span><span>rref <span style=color:#ff79c6>=</span> x; <span style=color:#6272a4>// 错误，右值引用不能绑定到左值
</span></span></span></code></pre></div><p>右值引用有容易迷惑的地方，比如一个函数的参数是右值引用，但是这个右值在函数调用时是左值。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span><span style=color:#8be9fd>void</span> <span style=color:#50fa7b>func</span>(<span style=color:#8be9fd>int</span><span style=color:#ff79c6>&amp;&amp;</span> ref) {
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2</span><span>    <span style=color:#6272a4>// ref 是右值引用, 但是在函数调用时是左值
</span></span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3</span><span><span style=color:#6272a4></span>    ref <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>100</span>; <span style=color:#6272a4>// 可以修改
</span></span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4</span><span><span style=color:#6272a4></span>}
</span></span></code></pre></div><p>两种引用在函数调用时的区别：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1</span><span><span style=color:#8be9fd>void</span> <span style=color:#50fa7b>func1</span>(<span style=color:#8be9fd>int</span><span style=color:#ff79c6>&amp;</span> ref) {
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2</span><span>    <span style=color:#6272a4>// ref 是左值引用
</span></span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3</span><span><span style=color:#6272a4></span>}
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4</span><span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5</span><span><span style=color:#8be9fd>void</span> <span style=color:#50fa7b>func2</span>(<span style=color:#8be9fd>int</span><span style=color:#ff79c6>&amp;&amp;</span> ref) {
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6</span><span>    <span style=color:#6272a4>// ref 是右值引用
</span></span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7</span><span><span style=color:#6272a4></span>}
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8</span><span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9</span><span><span style=color:#8be9fd>void</span> <span style=color:#50fa7b>func3</span>(<span style=color:#ff79c6>const</span> <span style=color:#8be9fd>int</span><span style=color:#ff79c6>&amp;</span> ref) {
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10</span><span>    <span style=color:#6272a4>// ref 是 const 左值引用
</span></span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11</span><span><span style=color:#6272a4></span>}
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12</span><span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13</span><span><span style=color:#8be9fd>int</span> <span style=color:#50fa7b>main</span>() {
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14</span><span>    <span style=color:#8be9fd>int</span> a <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>100</span>;
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15</span><span>    func1(a); <span style=color:#6272a4>// 正确 a 是左值
</span></span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16</span><span><span style=color:#6272a4></span>    func1(<span style=color:#bd93f9>101</span>); <span style=color:#6272a4>// 错误 101 是右值
</span></span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17</span><span><span style=color:#6272a4></span>    func2(<span style=color:#bd93f9>102</span>); <span style=color:#6272a4>// 正确 102 是右值
</span></span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">18</span><span><span style=color:#6272a4></span>    func2(a); <span style=color:#6272a4>// 错误 a 是左值
</span></span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">19</span><span><span style=color:#6272a4></span>    func3(a); <span style=color:#6272a4>// 正确 a 是左值
</span></span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">20</span><span><span style=color:#6272a4></span>    func3(<span style=color:#bd93f9>103</span>); <span style=color:#6272a4>// 正确 103 是右值
</span></span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">21</span><span><span style=color:#6272a4></span>}
</span></span></code></pre></div><h3 id=引用折叠><a href=#%e5%bc%95%e7%94%a8%e6%8a%98%e5%8f%a0 class=header-anchor></a>引用折叠</h3><p>引用折叠是C++11引入的新特性，也可以叫万能引用，用于简化引用的使用，主要用于模板的参数推导。
主要用在模板的参数推导中，当一个模板参数是引用时，引用折叠规则会决定最终的引用类型。</p><p>C++11引入右值引用 <code>T&&</code> 后，允许绑定到右值，同时在模板中可能出现复杂的类型推导情况，例如：</p><ul><li><code>T& &</code></li><li><code>T& &&</code></li><li><code>T&& &</code></li><li><code>T&& &&</code></li></ul><p>为了简化模板参数推导，引入了引用折叠规则：</p><p>引用折叠规则：</p><ul><li><code>T& & -> T&</code></li><li><code>T& && -> T&</code></li><li><code>T&& & -> T&</code></li><li><code>T&& && -> T&&</code></li></ul><p>简单来说,左值引用 <code>&</code> 具有优先级，只要组合中出现左值引用，最终结果就是左值引用。
右值引用 <code>&&</code> 只有在没有左值引用的情况下才会保留。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1</span><span><span style=color:#ff79c6>template</span><span style=color:#ff79c6>&lt;</span><span style=color:#ff79c6>typename</span> T<span style=color:#ff79c6>&gt;</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2</span><span><span style=color:#8be9fd>void</span> func(T<span style=color:#ff79c6>&amp;&amp;</span> param) {
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3</span><span>    <span style=color:#6272a4>// param 的类型取决于传入的值类别
</span></span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4</span><span><span style=color:#6272a4></span>}
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5</span><span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6</span><span><span style=color:#8be9fd>int</span> <span style=color:#50fa7b>main</span>() {
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7</span><span>    <span style=color:#8be9fd>int</span> x <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>100</span>;
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8</span><span>    func(x);      <span style=color:#6272a4>// T 推导为 int&amp;，T&amp;&amp; 折叠为 int&amp;
</span></span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9</span><span><span style=color:#6272a4></span>    func(<span style=color:#bd93f9>101</span>);     <span style=color:#6272a4>// T 推导为 int，T&amp;&amp; 保持为 int&amp;&amp;
</span></span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10</span><span><span style=color:#6272a4></span>}
</span></span></code></pre></div><ul><li>当传入左值<code>x</code>时，<code>T</code>推导为<code>int&</code>，<code>T&&</code>变成<code>int& &&</code>，折叠为<code>int&</code>。</li><li>当传入右值<code>101</code>时，<code>T</code>推导为<code>int</code>，<code>T&&</code>保持为<code>int&&</code>。</li></ul><p>引用折叠生效的一个前提是模板参数要发生类型推导，如果模板参数是明确的类型，引用折叠规则不会生效。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span><span style=color:#ff79c6>template</span><span style=color:#ff79c6>&lt;</span><span style=color:#ff79c6>typename</span> T<span style=color:#ff79c6>&gt;</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2</span><span><span style=color:#8be9fd>void</span> func(std<span style=color:#ff79c6>::</span>vector<span style=color:#ff79c6>&lt;</span>T<span style=color:#ff79c6>&gt;&amp;&amp;</span> param); <span style=color:#6272a4>// 普通右值引用，只能绑定右值
</span></span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1</span><span><span style=color:#ff79c6>template</span> <span style=color:#ff79c6>&lt;</span><span style=color:#ff79c6>typename</span> T<span style=color:#ff79c6>&gt;</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2</span><span><span style=color:#ff79c6>class</span> <span style=color:#50fa7b>A</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3</span><span>{
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4</span><span><span style=color:#ff79c6>public</span><span style=color:#ff79c6>:</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5</span><span>    <span style=color:#8be9fd>void</span> push(T<span style=color:#ff79c6>&amp;&amp;</span> t)
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6</span><span>    {
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7</span><span>        data_.push_back(std<span style=color:#ff79c6>::</span>forward<span style=color:#ff79c6>&lt;</span>T<span style=color:#ff79c6>&gt;</span>(t));
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8</span><span>    }
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9</span><span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10</span><span><span style=color:#ff79c6>private</span><span style=color:#ff79c6>:</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11</span><span>    std<span style=color:#ff79c6>::</span>vector<span style=color:#ff79c6>&lt;</span>T<span style=color:#ff79c6>&gt;</span> data_;
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12</span><span>};
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13</span><span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14</span><span><span style=color:#8be9fd>int</span> <span style=color:#50fa7b>main</span>() {
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15</span><span>    A<span style=color:#ff79c6>&lt;</span><span style=color:#8be9fd>int</span><span style=color:#ff79c6>&gt;</span> a;
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16</span><span>    <span style=color:#6272a4>// int x = 100;
</span></span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17</span><span><span style=color:#6272a4></span>    <span style=color:#6272a4>// a.push(x);     // 编译错误：左值不能绑定到右值引用
</span></span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">18</span><span><span style=color:#6272a4></span>    a.push(<span style=color:#bd93f9>101</span>);      <span style=color:#6272a4>// 正确：右值
</span></span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">19</span><span><span style=color:#6272a4></span>    <span style=color:#ff79c6>return</span> <span style=color:#bd93f9>0</span>;
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">20</span><span>}
</span></span></code></pre></div><p>这里的 <code>T&&</code> 是一个右值引用，但是在模板参数推导时，会根据传入的参数类型来决定最终的引用类型。
因为在初始化 <code>A</code> 类时，<code>T</code> 的类型已经确定了，所以 <code>T&&</code> 不会发生引用折叠。</p><p>改进</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1</span><span><span style=color:#ff79c6>template</span> <span style=color:#ff79c6>&lt;</span><span style=color:#ff79c6>typename</span> T<span style=color:#ff79c6>&gt;</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2</span><span><span style=color:#ff79c6>class</span> <span style=color:#50fa7b>A</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3</span><span>{
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4</span><span><span style=color:#ff79c6>public</span><span style=color:#ff79c6>:</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5</span><span>    <span style=color:#ff79c6>template</span> <span style=color:#ff79c6>&lt;</span><span style=color:#ff79c6>typename</span> U<span style=color:#ff79c6>&gt;</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6</span><span>    <span style=color:#8be9fd>void</span> push(U<span style=color:#ff79c6>&amp;&amp;</span> u)
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7</span><span>    {
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8</span><span>        data_.push_back(std<span style=color:#ff79c6>::</span>forward<span style=color:#ff79c6>&lt;</span>U<span style=color:#ff79c6>&gt;</span>(u));
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9</span><span>    }
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10</span><span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11</span><span><span style=color:#ff79c6>private</span><span style=color:#ff79c6>:</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12</span><span>    std<span style=color:#ff79c6>::</span>vector<span style=color:#ff79c6>&lt;</span>T<span style=color:#ff79c6>&gt;</span> data_;
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13</span><span>};
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14</span><span><span style=color:#8be9fd>int</span> <span style=color:#50fa7b>main</span>() {
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15</span><span>    A<span style=color:#ff79c6>&lt;</span><span style=color:#8be9fd>int</span><span style=color:#ff79c6>&gt;</span> a;
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16</span><span>    <span style=color:#8be9fd>int</span> x <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>100</span>;
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17</span><span>    a.push(x);         
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">18</span><span>    a.push(<span style=color:#bd93f9>101</span>);        
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">19</span><span>    <span style=color:#ff79c6>return</span> <span style=color:#bd93f9>0</span>;
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">20</span><span>}
</span></span></code></pre></div><p>这里的 <code>U&&</code> 是一个万能引用，它会根据传入的参数类型来决定最终的引用类型，所以可以正确的推导出左值和右值。</p><h2 id=总结><a href=#%e6%80%bb%e7%bb%93 class=header-anchor></a>总结</h2><p>C++中的变量可以分为左值和右值，右值又可以分为纯右值和将亡值。不同类型的变量的生命周期与作用域也是有差别的。</p><p>简单说有明确变量名，可以取地址，可以修改的是左值，没有明确变量名，不能取地址，不能修改的是右值。</p><p>左值和右值配合引用，可以更好的控制变量的生命周期，同时也会带来一些特殊的情况，比如引用折叠。</p><ul><li>左值引用：左值引用是一个别名，它是一个左值，可以取地址，可以修改。作为函数参数时，只能绑定左值。</li><li>const 左值引用：可以绑定到右值，但是不能修改。</li><li>右值引用：右值引用是一个新的引用类型，用于绑定到右值。作为函数参数时，只能绑定右值。</li><li>引用折叠：引用折叠是C++11引入的新特性，用于简化引用的使用，主要用于模板的参数推导。只有在发生类型推导时才会生效。</li></ul><p>左值引用和右值引用，应该要配合 <code>std::move</code> 和 <code>std::forward</code> 使用，这样可以更好的控制变量的生命周期。
这里先挖一个坑，后面有空再来聊这部分内容。</p></section><footer class=article-footer><section class=article-tags><a href=/tags/c++/>C++</a></section><section class=article-copyright><svg class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg>
<span><a rel="license external nofollow noopener noreferrer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>Licensed under CC BY-NC-SA 4.0</a></span></section><section class=article-copyright>暂时还懒得去弄评论区，有问题欢迎 <a href=mailto:lqxlucky@qq.com title=lqxlucky@qq.com rel=noopener target=_blank>邮件</a> 交流</section></footer><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css integrity=sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI+WdtXRGWt2kTvGFasHpSy3SV crossorigin=anonymous><script src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js integrity=sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG+vnGctmUb0ZY0l8 crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous defer></script><script>window.addEventListener("DOMContentLoaded",()=>{renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],ignoredClasses:["gist"]})})</script></article><aside class=related-content--wrapper><h2 class=section-title>相关文章</h2><div class=related-content><div class="flex article-list--tile"><article class=has-image><a href=/posts/541b707d/><div class=article-image><img src=https://cdn.jsdelivr.net/gh/lqxhub/images@master/blog/6271dad17bae0c4a3d2fd061106001be135c745e.jpg loading=lazy data-key=541b707d data-hash=https://cdn.jsdelivr.net/gh/lqxhub/images@master/blog/6271dad17bae0c4a3d2fd061106001be135c745e.jpg></div><div class=article-details><h2 class=article-title>C++20协程入门篇</h2></div></a></article><article class=has-image><a href=/posts/14155cf4/><div class=article-image><img src=https://cdn.jsdelivr.net/gh/lqxhub/images@master/blog/7320b79a5cd9f9ac9e07752081db9612e98ca223.jpg loading=lazy data-key=14155cf4 data-hash=https://cdn.jsdelivr.net/gh/lqxhub/images@master/blog/7320b79a5cd9f9ac9e07752081db9612e98ca223.jpg></div><div class=article-details><h2 class=article-title>C++中的移动语义与完美转发</h2></div></a></article><article class=has-image><a href=/posts/f0e9829c/><div class=article-image><img src=https://cdn.jsdelivr.net/gh/lqxhub/images@master/blog/6a84474a44a97bccecbbc9c5a3b9f7aea2571c97.jpg loading=lazy data-key=f0e9829c data-hash=https://cdn.jsdelivr.net/gh/lqxhub/images@master/blog/6a84474a44a97bccecbbc9c5a3b9f7aea2571c97.jpg></div><div class=article-details><h2 class=article-title>Linux下使用iouring实现一个tcp服务</h2></div></a></article><article class=has-image><a href=/posts/b810e905/><div class=article-image><img src=https://cdn.jsdelivr.net/gh/lqxhub/images@master/blog/7e0d79d47f0173b9b7a0c351c5d719303aa0f0e8.png loading=lazy data-key=b810e905 data-hash=https://cdn.jsdelivr.net/gh/lqxhub/images@master/blog/7e0d79d47f0173b9b7a0c351c5d719303aa0f0e8.png></div><div class=article-details><h2 class=article-title>C++动态加载so/dll库</h2></div></a></article><article><a href=/posts/d9a4c4a4/><div class=article-details><h2 class=article-title>pika编译笔记</h2></div></a></article></div></div></aside><footer class=site-footer><section class=copyright>&copy;
2021 -
2026 QX 的笔记</section><section class=totalcount>发表了67篇文章 ·
总计171.19k字</section><footer class=running-time>本博客已稳定运行
<span id=runningdays class=running-days></span></footer><section class=powerby>© QX<br>使用 <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a> 构建<br>主题 <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.27.0>Stack</a></b> 由 <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a> 设计</section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.js defer></script><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script><script>let s1="2021-10-1";s1=new Date(s1.replace(/-/g,"/"));let s2=new Date,timeDifference=s2.getTime()-s1.getTime(),days=Math.floor(timeDifference/(1e3*60*60*24)),hours=Math.floor(timeDifference%(1e3*60*60*24)/(1e3*60*60)),minutes=Math.floor(timeDifference%(1e3*60*60)/(1e3*60)),result=days+"天"+hours+"小时"+minutes+"分钟";document.getElementById("runningdays").innerHTML=result</script></body></html>